# my-make-things

This repo contains a complete make system that (hopefully)
scales-up to support building a complex project. This code
started with maxtrua's Makefile project for handling dependency
files (generation and loading) and grew from there. I built this
as a skeleton for a large project at work.

At first glance, it will seem like there is an over-abundance of
comments in the code files. This is intentional on my part for
two reasons. First, people are so used to reading things on the
web, anything that's not a two sentence paragraph or a bulleted
list is ignored.

The second reason is I don't believe in self-documenting
code. It's like unicorns: we may dream of them but they don't
exist. After more than 35 years of writing code, I've seen
a *lot* of code. Much of it the author claimed was self-commenting.
Yet, if you took the self-documenting code back to the author a
few weeks or months later, they had to spend a fair amount of time
studying it to figure out what it did.

Bottom line: if the comments are in the way, feel free to delete
them.

## Organization of Make Files

How the make system is laid out. First the build system files...

* build_system/build_library/makefile - this the main driver for
all components is the same across the project; tailoring happens
in the component.mk file for each component
* build_system/build_library/defaults.mk - contains the default
definitions of tools, etc used in this project
* build_system/build_library/compiler_rules.mk - define's the
default recipes to comile, etc

Now files for individual components that we are building...

* hello/component.mk - tailors the program to be built; gets
functionality from a_dir object files
* a_dir/component.mk - tailors the make system for this component;
this component has two functions (as object files) used by hello.c's
main()
* b_dir/component.mk - tailors the make system for this component;
this component has two functions used by hello.c's main(); the
difference is these functions are in object files stored in an
archive (a library made using the ar command); a table of contents
is created from the archive file

## make Targets

A standard set of targets are defined in the makefile. Use
these target to build, etc.

* all - this is the default target and it directs make to build
everything; defined in component.mk
* clean - use this target  clean-up flotsam from a prior build
but leave some things as they are, e.g., the dependency files;
defined in makefile
* cleanall - use this target to clean-up everything that was
generated by a prior build; defined in makefile
* checkit - outputs the configuration of the make system for
this component; defined in makefile
* docs - used to generate the project documentation using
Doxygen

## Other Trivia

Every subdirectory under src should have its own Doxyfile,
the configuration file used with Doxygen to generate project
documentation. This is the only file (along with component.mk)
that every component should have. For a really large project,
it may be worth looking at creating a generic Doxyfile for the
project (or portions of the project). See [issue \#1](https://github.com/neocliff/my-make-things/issues/1)
for ideas on that.

## About the Project

This project is a glorified "Hello, World!". I created enough
in the way of source code to test the build system. It contains:

* [src/hello](https://github.com/neocliff/my-make-things/blob/master/src/hello) -
This is the directory has hello.c containing main()
and a single header, include/hello.h. The header has a BITSIZE #define
that is controlled by an externally specified make file, component.mk.
main() calls functions defined in a_dir and b_dir source code files.
Those files are linked to hello and the include directories are
added to the INCLUDE_DIRS variable in component.mk.
* [src/hello/c_dir](https://github.com/neocliff/my-make-things/blob/master/src/hello/c_dir) -
This subdirectory of src/hello demonstrates that
a component can have directories within it. This is a useful way of
partitioning functionality.
* [src/a_dir](https://github.com/neocliff/my-make-things/blob/master/src/a_dir) -
This directory has two source files, a.c and a2.c,
each with a corresponding header file. The function in a.c (called
a()) calls a function a2() in a2.c. These source files are compiled
to object code (.o files) and the .o files are linked into hello.
* [src/b_dir](https://github.com/neocliff/my-make-things/blob/master/src/b_dir) -
This directory has two source files, b1.c and b2.c,
and a single header file called include/b.h. hello's main() calls
b1() (b1.c) and b1() calls b2() (in b2.c). These source files
are compiled to object files (.o's). The .o files are then added
to an archive (or library). That .ar file is then linked into
hello.
* [src/shared/s_dir_YYMMDD](https://github.com/neocliff/my-make-things/blob/master/src/shared) -
The two subdirectories in src/shared present an
approach for handling instances where multiple versions of the same
files are used. On a large project with multiple binaries and
components, it is not out of the question that multiple versions
of the same library would be used. The best way to deal with this
is to rationalize the library into a single version however that isn't
always possible. The file [src/hello/component.mk](https://github.com/neocliff/my-make-things/blob/master/src/hello/component.mk)
has details for secting the library version.

As I said, this source is contrived and is intended to prove
capability of the make build system. Hopefully, you find it
a useful starting point for your own projects.
